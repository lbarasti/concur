require "rate_limiter"

module Concur
  # Returns a channel that will receive each element in the given enumerable,
  # and then close.
  def source(input : Enumerable(T), name = nil, buffer_size = 0) : Channel(T) forall T
    Channel(T).new(buffer_size).tap { |stream|
      spawn(name: name) do
        input.each { |value|
          stream.send value
        }
      ensure
        stream.close
      end
    }
  end

  # Returns a channel that will receive each value generated by recursively calling
  # *block*, starting from the given *initial_state*.
  #
  # If an exception is raised while running a block, then the returned channel will be closed.
  #
  # Note. *block* is a function returning a tuple composed of the next state
  # to be passed to the block and the next value to be received by the returned channel.
  def source(initial_state : S, name = nil, buffer_size = 0, &block : S -> {S, V}) forall S, V
    Channel(V).new(buffer_size).tap { |stream|
      spawn(name: name) do
        state = initial_state
        loop do
          state, value = block.call(state)
          stream.send value
        end
      ensure
        stream.close
      end
    }
  end

  # Returns a channel that will receive the value returned by *block* at
  # intervals of at least *t* between one call and the other.
  #
  # If an exception is raised while running a block, then the returned channel will be closed.
  #
  # An optional channel `terminate` can be passed to the method. Sending an object to this
  # channel - or closing it - will halt the sending of new values as soon as any outstanding run of *block*
  # is completed and close the returned channel.
  #
  # Note. Only a single instance of *block* can be running at any given time. If the
  # block takes a time `x` to complete, then the time between two runs of *block* will be
  # at least `t + x`.
  def every(t : Time::Span, name = nil, buffer_size = 0, terminate = Channel(Time).new, &block : -> T) : Channel(T) forall T
    Channel(T).new(buffer_size).tap { |stream|
      spawn(name: name) do
        loop do
          select
          when timeout(t)
            stream.send block.call
          when time = terminate.receive?
            break
          end
        end
      ensure
        stream.close
      end
    }
  end

  # Returns a channel that will receive each element of the enumerables received by
  # *in_stream*, one at a time.
  #
  # If *in_stream* is closed, then the returned stream will also be closed once *in_stream* has been emptied.
  def flatten(in_stream : Channel(Enumerable(K)), name = nil, buffer_size = 0) : Channel(K) forall K
    Channel(K).new(buffer_size).tap { |stream|
      spawn(name: name) do
        loop do
          in_stream.receive.each { |v|
            stream.send(v)
          }
        end
      rescue Channel::ClosedError
        stream.close
      end
    }
  end
end

abstract class ::Channel(T)

  # Returns a channel that receives values from both *self* and *other*, as soon as they are available.
  #
  # The returned channel is closed as soon as both the input channels are closed and empty - but will
  # continue to operate while at least one of them is open.
  #
  # Note. If both channels have values ready to be received, then one will be selected at random. 
  def merge(other : Channel(J), name = nil, buffer_size = 0) : Channel(T | J) forall J
    channels = [self, other]
    Channel(T | J).new(buffer_size).tap { |stream|
      spawn(name: name) do
        loop do
          stream.send Channel.receive_first(channels.shuffle) # shuffle to increase fairness
        rescue Channel::ClosedError
          channels.reject!(&.closed?)
          break if channels.empty?
        end
        stream.close
      end
    }
  end

  # Returns a channel that receives at most *items_per_sec* items per second from the
  # caller - or *max_burst* items, if no elements were received in a while.
  #
  # The returned channel is closed once `self` is closed and empty and a new value
  # can be received, based on the rate limiting parameters.
  #
  # Refer to the documentation of [RateLimiter](https://github.com/lbarasti/rate_limiter)
  # for more details.
  def rate_limit(items_per_sec : Float64, max_burst : Int32 = 1, name = nil, buffer_size = 0)
    rl = RateLimiter.new(rate: items_per_sec, max_burst: max_burst)

    Channel(T).new(buffer_size).tap { |stream|
      spawn(name: name) do
        loop do
          rl.get
          stream.send self.receive
        end
      rescue Channel::ClosedError
        stream.close
      end
    }
  end

  # Returns a channel that receives values from `self` transformed via *block*.
  #
  # A *workers* parameter can be supplied to make the computation of the block concurrent.
  # Note that, for *workers* > 1, no order guarantees are made.
  #
  # The returned channel will close once `self` is closed and empty, and all
  # the outstanding runs of `block` are completed.
  #
  # Example:
  # ```
  # source([1,2,3])
  #   .map(workers: 2) { |v| sleep rand; v**2 } # => [4, 1, 9]
  # ```
  def map(workers = 1, name = nil, buffer_size = 0, &block : T -> V) : Channel(V) forall V
    Channel(V).new(buffer_size).tap { |stream|
      countdown = Channel(Nil).new(workers)
      workers.times { |w_i|
        spawn(name: name.try { |s| "#{s}.#{w_i}" }) do
          self.listen { |v|
            stream.send block.call(v)
          }
        ensure
          countdown.send(nil)
        end
      }
      spawn(name: name.try { |s| "#{s}.countdown" }) do
        workers.times { countdown.receive }
        countdown.close
        stream.close
      end
    }
  end

  def flat_map(workers = 1, name = nil, buffer_size = 0, &block : T -> Enumerable(V)) : Channel(V) forall V
    enum_stream = map(
      workers: workers, name: name.try{ |s| "#{s}.map" }, &block)
    flatten(enum_stream, buffer_size: buffer_size, name: name)
  end

  def map(initial_state : S, buffer_size = 0, name = nil, &block : S, T -> V) forall S,V
    state = initial_state
    self.map(name: name, buffer_size: buffer_size) { |t|
      state, v = block.call(state, t)
      v
    }
  end

  def scan(acc : U, buffer_size = 0, name = nil, &block : U,T -> U) : Channel(U) forall U
    Channel(U).new(buffer_size).tap { |stream|
      spawn(name: name) do
        self.listen { |v|
          acc = block.call(acc, v)
          stream.send acc
        }
        stream.close()
      end
    }
  end

  def zip(channel : Channel(U), name = nil, buffer_size = 0, &block : T,U -> V) : Channel(V) forall U,V
    Channel(V).new(buffer_size).tap { |stream|
      spawn(name: name) do
        loop do
          p1 = self.receive
          p2 = channel.receive

          stream.send block.call(p1,p2)
        end
      rescue Channel::ClosedError
        puts "#{Fiber.current.name} rescuing"
        stream.close
      end
    }
  end

  # TODO define a macro to return a Tuple
  def broadcast(out_ports = 2, name = nil)
    out_ports.times.map { Channel(T).new }.to_a.tap { |streams|
      spawn(name: name) do
        self.listen { |v|
          streams.each(&.send(v))
        }
        streams.each(&.close())
      end
    }
  end

  def select(name = nil, &predicate : T -> Bool) : Channel(T)
    Channel(T).new.tap { |selected|
      spawn(name: name) do
        loop do
          v = self.receive
          predicate.call(v) ? selected.send(v) : nil
        end
      rescue Channel::ClosedError
        selected.close
      end
    }
  end

  def reject(name = nil, &predicate : T -> Bool) : Channel(T)
    self.select(name: name) { |v|
      !predicate.call(v)
    }
  end

  def partition(&predicate : T -> Bool) : {Channel(T), Channel(T)}
    {Channel(T).new, Channel(T).new}.tap { |pass, fail|
      spawn do
        self.listen { |v|
          predicate.call(v) ? (pass.send(v)) : (fail.send(v))
        }
      end
    }
  end

  # Sends batches of messages either every `size` messages received or every `interval`,
  # if a batch has not been sent within the last `interval`.
  def batch(size : Int32, interval : Time::Span, name = nil) : Channel(Enumerable(T))
    # TODO: assert on `size` and `interval`
    Channel(Enumerable(T)).new.tap { |out_stream|
      memory = Array(T).new(size)
      tick = every(interval) { nil }
      sent = false
      spawn(name: name) do
        loop do
          select
          when v = self.receive
            memory << v
            if memory.size >= size
              out_stream.send(memory.dup)
              memory.clear
              sent = true
            end
          when tick.receive
            unless sent
              out_stream.send(memory.dup)
              memory.clear
            end
            sent = false
          end
        end
      rescue Channel::ClosedError
        out_stream.send(memory.dup)
        out_stream.close
      end
    }
  end

  def listen(&block : T ->)
    loop do
      block.call(self.receive)
    rescue Channel::ClosedError
      puts "#{Fiber.current.name} rescuing"
      break
    end
  end

  def each(name = nil, &block : T -> )
    spawn(name: name) do
      loop do
        block.call(self.receive)
      rescue Channel::ClosedError
        break
      end
    end
  end
end
