require "rate_limiter"

module Concur
  extend self

  # Returns a channel that will receive each element in the given enumerable,
  # and then close.
  def source(input : Enumerable(T), name = nil, buffer_size = 0) : Channel(T) forall T
    Channel(T).new(buffer_size).tap { |stream|
      spawn(name: name) do
        input.each { |value|
          stream.send value
        }
      ensure
        stream.close
      end
    }
  end

  # Returns a channel that will receive each value generated by recursively calling
  # *block*, starting from the given *initial_state*.
  #
  # If an exception is raised while running a block, then the returned channel will be closed.
  #
  # NOTE: *block* is a function returning a tuple composed of the next state
  # to be passed to the block and the next value to be received by the returned channel.
  def source(initial_state : S, name = nil, buffer_size = 0, &block : S -> {S, V}) forall S, V
    Channel(V).new(buffer_size).tap { |stream|
      spawn(name: name) do
        state = initial_state
        loop do
          state, value = block.call(state)
          stream.send value
        end
      ensure
        stream.close
      end
    }
  end

  # Returns a channel that will receive the value returned by *block* at
  # intervals of at least *t* between one call and the other.
  #
  # If an exception is raised while running a block, then the returned channel will be closed.
  #
  # An optional channel `terminate` can be passed to the method. Sending an object to this
  # channel - or closing it - will halt the sending of new values as soon as any outstanding run of *block*
  # is completed and close the returned channel.
  #
  # NOTE: Only a single instance of *block* can be running at any given time. If the
  # block takes a time `x` to complete, then the time between two runs of *block* will be
  # at least `t + x`.
  def every(t : Time::Span, name = nil, buffer_size = 0, terminate = Channel(Time).new, &block : -> T) : Channel(T) forall T
    Channel(T).new(buffer_size).tap { |stream|
      spawn(name: name) do
        loop do
          select
          when timeout(t)
            stream.send block.call
          when time = terminate.receive?
            break
          end
        end
      ensure
        stream.close
      end
    }
  end

  # Returns a channel that will receive each element of the enumerables received by
  # *in_stream*, one at a time.
  #
  # If *in_stream* is closed, then the returned stream will also be closed once *in_stream* has been emptied.
  def flatten(in_stream : Channel(Enumerable(K)), name = nil, buffer_size = 0) : Channel(K) forall K
    Channel(K).new(buffer_size).tap { |stream|
      spawn(name: name) do
        loop do
          in_stream.receive.each { |v|
            stream.send(v)
          }
        end
      rescue Channel::ClosedError
        stream.close
      end
    }
  end
end
