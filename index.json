{"repository_name":"concur","body":"![GitHub release](https://img.shields.io/github/release/lbarasti/concur.svg)\n![Build Status](https://github.com/lbarasti/concur/workflows/spec_and_docs/badge.svg)\n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](https://opensource.org/licenses/MIT)\n[![Docs](https://img.shields.io/badge/docs-available-brightgreen.svg)](https://lbarasti.github.io/concur)\n\n# concur\n\nConcur is organised around two APIs:\n* A `Future` API to deal with asynchronous computations\n* An augmented `Channel` API with primitives to simplify event-driven programming.\n\n## Installation\n\nAdd the dependency to your `shard.yml` and run `shards install`:\n\n  ```yaml\n  dependencies:\n    concur:\n      github: lbarasti/concur\n  ```\n\n## Usage\n\n```crystal\nrequire \"concur\"\n```\n\n### Using Future\nYou can use `Future` to wrap asynchronous computations that might fail.\n```crystal\nf = Future.new {\n  sleep 2 # a placeholder for some expensive computation or for a lengthy IO operation\n  \"Success!\"\n}\n\nf.await # => \"Success!\"\n```\nIf you want to keep on manipulating the result of a future in a separate fiber, then you can rely on `Future`'s instance methods.\n\nFor example, given a future `f`, you can apply a function to the wrapped value with `#map`, filter it with `#select` and recover from failure with `#recover`\n\n```crystal\nf.map { |v| v.downcase }\n  .select { |v| v.size < 3 }\n  .recover { \"default_key\" }\n```\n\nHere is a contrived example to showcase some other common methods.\n\nYou can combine the result of two Futures into one with `#zip`:\n\n```crystal\nauthor_f : Future(User) = db.user_by_id(1)\nreviewer_f : Future(User) = db.user_by_id(2)\n\npermission_f : Future(Bool) = author_f.zip(reviewer_f) { |author, reviewer|\n  author.has_reviewer?(reviewer) \n}\n```\n\nYou can use `#flat_map` to avoid nesting futures:\n\n```crystal\ncontent_f : Future(Content) = permission_f\n  .flat_map { |reviewer_is_allowed|\n    if reviewer_is_allowed\n      db.content_by_user(1) # => Future(Content)\n    else\n      raise NotAllowedError.new\n    end\n  }\n```\n\nAnd perform side effects with `#on_success` and `#on_error`.\n\n```crystal\ncontent_f\n  .on_success { |content|\n    reviewer_f.await!.email(content)\n  }\n  .on_error { |ex| log_error(ex) }\n```\n\n### Using Channel\nConcur tries to increase the usability of `Channel` by adding a collection of transformation and callback methods to its API.\n\n#### Sources: the beginning and the end\nA Concur flow usually starts with a *source*.\n\n```crystal\ns1 = Concur.source(1..10) # returns a Channel(Int32) receiving each value of the range\n\ns2 = Concur.source(initial_state: 0) { |state| (state + 1)**2 } # returns a Channel(Int32) receiving the values (i + 1)^2 for i = 0,1,...\n\ns3 = Concur.every(1.second) { Time.utc } # returns a Channel(Time) receiving a timestamp approximately every second\n```\n\nSources can also be built by simply defining a channel and having some fiber send values to it. For example, suppose you want your application to react to some keyboard event\nthat lets you register a callback:\n\n```crystal\ns4 = Channel(KeyboardEvent).new\nkeybord.on_keypress { |event| s4.send event }\n```\n\nNow that we have some sources, we can leverage Concur's API to materialise them or define some callbacks that will run every\ntime the channel receives a value.\n\n```crystal\ns1.listen { |v| puts v } # prints values from 1 to 10\n\ns2.take(3) # => [1, 4, 25]\n\ns3.each { |time|\n  puts \"you're living in the past\" if time.year < 2022\n}\n```\n\n#### Sources: the middle\nWe've seen how we can create a source and how we can *consume* it. Let's now look at how we can transform it.\n\nHere is an example where we merge two event streams, batch them, process them into a new state and then persist that.\n\n```crystal\nkeypress = Channel(KeyboardEvent).new\nmouse_click = Channel(MouseEvent).new\n\n# persist the state of the system every 5 events or every second,\n# whichever happens first\nkeypress.merge(mouse_click)\n  .batch(size: 5, interval: 1.seconds)\n  .scan({\"\", {0,0}}) { |state, events|\n    events.reduce(state) { |s, e|\n      case e\n      in MouseEvent\n        {s[0], e.pos}\n      in KeyboardEvent\n        {s[0] + e.key, s[1]}\n      end\n    }\n  }.each { |state| persist(state) }\n```\n\nConcur also lets you spin off concurrent computations very easily. Here is an example\nwhere we let 4 workers compute the distance of a 2D point from the origin of a Cartesian plane.\nWe then produce [an estimate of the constant Pi](https://en.wikipedia.org/wiki/Approximations_of_%CF%80#Summing_a_circle's_area) and look at how many iterations it took the process\nto generate 10 consecutive estimates with a relative error of less than `1e-5`.\n\n```crystal\nsource(Random.new) { |gen| {gen, {gen.rand, gen.rand}} }\n  .map(workers: 4) { |(x,y)| x**2 + y**2 }\n  .scan({0, 0}) { |acc, v|\n    v <= 1 ? {acc[0] + 1, acc[1]} : {acc[0], acc[1] + 1}\n  }.map { |(inner, outer)| 4 * inner / (inner + outer)}\n  .zip(source(1..)) { |estimate, iteration| {iteration, estimate} }\n  .batch(10, 1.second)\n  .select { |estimates|\n    estimates.all? { |(i, e)|\n      (e - Math::PI).abs / Math::PI < 1e-5\n    }\n  }.flat_map { |estimates| estimates.map(&.first) }\n  .take 1 # => [235191]\n```\n\nCheck out the [API docs](https://lbarasti.com/concur/) and the `/examples` folder for more details.\n\n## Development\n\nRun `shards install` to install the project dependencies. You can then run `crystal spec` to verify that all the tests are passing.\n\n## Contributing\n\n1. Fork it (<https://github.com/lbarasti/concur/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [lbarasti](https://github.com/lbarasti) - creator and maintainer\n","program":{"html_id":"concur/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"locations":[],"repository_name":"concur","program":true,"enum":false,"alias":false,"const":false,"types":[{"html_id":"concur/Channel","path":"Channel.html","kind":"class","full_name":"Channel(T)","name":"Channel","abstract":false,"superclass":{"html_id":"concur/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"concur/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"concur/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/concur/channel.cr","line_number":3,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L3"}],"repository_name":"concur","program":false,"enum":false,"alias":false,"const":false,"doc":"A `Channel` enables concurrent communication between fibers.\n\nThey allow communicating data between fibers without sharing memory and without having to worry about locks, semaphores or other special structures.\n\n```\nchannel = Channel(Int32).new\n\nspawn do\n  channel.send(0)\n  channel.send(1)\nend\n\nchannel.receive # => 0\nchannel.receive # => 1\n```\n\nNOTE: Although a `Channel(Nil)` or any other nilable types like `Channel(Int32?)` are valid\nthey are discouraged since from certain methods or constructs it receiving a `nil` as data\nwill be indistinguishable from a closed channel.\n","summary":"<p>A <code><a href=\"Channel.html\">Channel</a></code> enables concurrent communication between fibers.</p>","instance_methods":[{"html_id":"batch(size:Int32,interval:Time::Span,name=nil,buffer_size=0):Channel(Enumerable(T))-instance-method","name":"batch","doc":"Returns a channel that receives values in batches either every *size* values\nreceived or every *interval*, if a batch has not been sent within the last *interval*.\n\nThe returned channels will close once `self` is closed and empty.","summary":"<p>Returns a channel that receives values in batches either every <em>size</em> values received or every <em>interval</em>, if a batch has not been sent within the last <em>interval</em>.</p>","abstract":false,"args":[{"name":"size","external_name":"size","restriction":"Int32"},{"name":"interval","external_name":"interval","restriction":"Time::Span"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"args_string":"(size : Int32, interval : Time::Span, name = nil, buffer_size = 0) : Channel(Enumerable(T))","args_html":"(size : Int32, interval : Time::Span, name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>) : <a href=\"Channel.html\">Channel</a>(Enumerable(T))","location":{"filename":"src/concur/channel.cr","line_number":312,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L312"},"def":{"name":"batch","args":[{"name":"size","external_name":"size","restriction":"Int32"},{"name":"interval","external_name":"interval","restriction":"Time::Span"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"return_type":"Channel(Enumerable(T))","visibility":"Public","body":"(Channel(Enumerable(T)).new(buffer_size)).tap do |stream|\n  memory = Array(T).new(size)\n  tick = Concur.every(interval) do\n    nil\n  end\n  sent = false\n  spawn(name: name) do\n    begin\n      loop do\n        select\nwhen v = self.receive\n          memory << v\n          if memory.size >= size\n            stream.send(memory.dup)\n            memory.clear\n            sent = true\n          end\nwhen tick.receive\n          if sent\n          else\n            stream.send(memory.dup)\n            memory.clear\n          end\n          sent = false\nend\n\n      end\n    rescue Channel::ClosedError\n      stream.send(memory.dup)\n      stream.close\n    end\n  end\nend"}},{"html_id":"broadcast(out_ports=2,name=nil,buffer_size=0):Array(Channel(T))-instance-method","name":"broadcast","doc":"Returns an array of *out_ports* channels which receive each value\nreceived by `self`.\n\nThe returned channels will close once `self` is closed and empty.\n\nIf one of the returned channels is closed, then `#broadcast` will\nclose every other channel.\n\nNOTE: The rate at which values are received by each channel is limited\nby the slowest consumer. Values are sent to channels in the order they\nwere returned.","summary":"<p>Returns an array of <em>out_ports</em> channels which receive each value received by <code>self</code>.</p>","abstract":false,"args":[{"name":"out_ports","default_value":"2","external_name":"out_ports","restriction":""},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"args_string":"(out_ports = 2, name = nil, buffer_size = 0) : Array(Channel(T))","args_html":"(out_ports = <span class=\"n\">2</span>, name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>) : Array(<a href=\"Channel.html\">Channel</a>(T))","location":{"filename":"src/concur/channel.cr","line_number":221,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L221"},"def":{"name":"broadcast","args":[{"name":"out_ports","default_value":"2","external_name":"out_ports","restriction":""},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"return_type":"Array(Channel(T))","visibility":"Public","body":"out_ports.times.map do\n  Channel(T).new(buffer_size)\nend.to_a.tap do |streams|\n  spawn(name: name) do\n    self.listen do |v|\n      streams.each(&.send(v))\n    end\n    streams.each(&.close)\n  end\nend"}},{"html_id":"each(name=nil,&block:T->_)-instance-method","name":"each","doc":"Runs the given *block* for each value received from `self`.\nThe execution of the block takes place on a separate fiber.\n\nThe fiber running the block will stop once `self` is closed and empty.\n\nNOTE: If exceptions are not handled within *block*, then any exception\nraised within the block will crash the spawned fiber.","summary":"<p>Runs the given <em>block</em> for each value received from <code>self</code>.</p>","abstract":false,"args":[{"name":"name","default_value":"nil","external_name":"name","restriction":""}],"args_string":"(name = nil, &block : T -> _)","args_html":"(name = <span class=\"n\">nil</span>, &block : T -> _)","location":{"filename":"src/concur/channel.cr","line_number":366,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L366"},"def":{"name":"each","args":[{"name":"name","default_value":"nil","external_name":"name","restriction":""}],"yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T -> _)"},"visibility":"Public","body":"spawn(name: name) do\n  self.listen(&block)\nend"}},{"html_id":"flat_map(workers=1,name=nil,buffer_size=0,on_error=->(t:T,ex:Exception)do\nend,&block:T->Enumerable(V)):Channel(V)forallV-instance-method","name":"flat_map","doc":"Returns a channel that receives each value of the enumerables produced\napplying *block* to values received by `self`.\n\nA *workers* parameter can be supplied to make the computation of the block concurrent.\nNote that, for *workers* > 1, no order guarantees are made - see `#map` for an example.\n\nThe returned channel is closed once `self` is closed and empty, and all\nthe outstanding runs of *block* are completed.\n\nSee `#map` for details on the exception handling strategy.","summary":"<p>Returns a channel that receives each value of the enumerables produced applying <em>block</em> to values received by <code>self</code>.</p>","abstract":false,"args":[{"name":"workers","default_value":"1","external_name":"workers","restriction":""},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"args_string":"(workers = 1, name = nil, buffer_size = 0, on_error = ->(t : T, ex : Exception) do\nend, &block : T -> Enumerable(V)) : Channel(V) forall V","args_html":"(workers = <span class=\"n\">1</span>, name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, on_error = -&gt;(t : <span class=\"t\">T</span>, ex : <span class=\"t\">Exception</span>) <span class=\"k\">do</span>\n<span class=\"k\">end</span>, &block : T -> Enumerable(V)) : <a href=\"Channel.html\">Channel</a>(V) forall V","location":{"filename":"src/concur/channel.cr","line_number":120,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L120"},"def":{"name":"flat_map","args":[{"name":"workers","default_value":"1","external_name":"workers","restriction":""},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T -> Enumerable(V))"},"return_type":"Channel(V)","visibility":"Public","body":"enum_stream = map(workers: workers, name: name.try do |s|\n  \"#{s}.map\"\nend, on_error: on_error, &block)\nConcur.flatten(enum_stream, name, buffer_size)\n"}},{"html_id":"listen(&block:T->_)-instance-method","name":"listen","doc":"Receives values from `self` and processes them via *block*.\n\nIf no exceptions are raised while evaluating *block*, then the\nstatement returns once `self` is closed and empty.\n\nNOTE: This method runs on the current fiber.\n\nNOTE: If exceptions are not handled within *block*, then any exception\nraised within the block will crash the calling fiber.","summary":"<p>Receives values from <code>self</code> and processes them via <em>block</em>.</p>","abstract":false,"location":{"filename":"src/concur/channel.cr","line_number":351,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L351"},"def":{"name":"listen","yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T -> _)"},"visibility":"Public","body":"loop do\n  begin\n    block.call(self.receive)\n  rescue Channel::ClosedError\n    break\n  end\nend"}},{"html_id":"map(initial_state:S,name=nil,buffer_size=0,on_error=->(t:T,ex:Exception)do\nend,&block:S,T->Tuple(S,V))forallS,V-instance-method","name":"map","doc":"Returns a channel that receives values from `self` transformed via *block* and based\non the provided *initial_state*.\n\nNOTE: *block* is a function that takes the current state and a value received\nfrom `self` and returns a tuple composed of the next state to be passed to the block\nand the next value to be received by the returned channel.\n\nThe returned channel is closed once `self` is closed and empty, and any outstanding\nrun of *block* is completed.\n\nSee `#map` for details on the exception handling strategy.","summary":"<p>Returns a channel that receives values from <code>self</code> transformed via <em>block</em> and based on the provided <em>initial_state</em>.</p>","abstract":false,"args":[{"name":"initial_state","external_name":"initial_state","restriction":"S"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"args_string":"(initial_state : S, name = nil, buffer_size = 0, on_error = ->(t : T, ex : Exception) do\nend, &block : S, T -> Tuple(S, V)) forall S, V","args_html":"(initial_state : S, name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, on_error = -&gt;(t : <span class=\"t\">T</span>, ex : <span class=\"t\">Exception</span>) <span class=\"k\">do</span>\n<span class=\"k\">end</span>, &block : S, T -> Tuple(S, V)) forall S, V","location":{"filename":"src/concur/channel.cr","line_number":143,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L143"},"def":{"name":"map","args":[{"name":"initial_state","external_name":"initial_state","restriction":"S"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"yields":2,"block_arg":{"name":"block","external_name":"block","restriction":"(S, T -> ::Tuple(S, V))"},"visibility":"Public","body":"state = initial_state\nself.map(name: name, buffer_size: buffer_size, on_error: on_error) do |t|\n  state, v = block.call(state, t)\n  v\nend\n"}},{"html_id":"map(workers=1,name=nil,buffer_size=0,on_error=->(t:T,ex:Exception)do\nend,&block:T->V):Channel(V)forallV-instance-method","name":"map","doc":"Returns a channel that receives values from `self` transformed via *block*.\n\nA *workers* parameter can be supplied to make the computation of the block concurrent.\nNote that, for *workers* > 1, no order guarantees are made.\n\nThe returned channel will close once `self` is closed and empty, and all\nthe outstanding runs of *block* are completed.\n\nAny exception raised while evaluating *block* will be passed\nto the optional callback *on_error*, together with the value that\ntriggered the error.\n\nExample:\n```\nsource([1,2,3])\n  .map(workers: 2) { |v| sleep rand; v**2 } # => [4, 1, 9]\n```","summary":"<p>Returns a channel that receives values from <code>self</code> transformed via <em>block</em>.</p>","abstract":false,"args":[{"name":"workers","default_value":"1","external_name":"workers","restriction":""},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"args_string":"(workers = 1, name = nil, buffer_size = 0, on_error = ->(t : T, ex : Exception) do\nend, &block : T -> V) : Channel(V) forall V","args_html":"(workers = <span class=\"n\">1</span>, name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, on_error = -&gt;(t : <span class=\"t\">T</span>, ex : <span class=\"t\">Exception</span>) <span class=\"k\">do</span>\n<span class=\"k\">end</span>, &block : T -> V) : <a href=\"Channel.html\">Channel</a>(V) forall V","location":{"filename":"src/concur/channel.cr","line_number":79,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L79"},"def":{"name":"map","args":[{"name":"workers","default_value":"1","external_name":"workers","restriction":""},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T -> V)"},"return_type":"Channel(V)","visibility":"Public","body":"(Channel(V).new(buffer_size)).tap do |stream|\n  countdown = Channel(Nil).new(workers)\n  workers.times do |w_i|\n    spawn(name: name.try do |s|\n      \"#{s}.#{w_i}\"\n    end) do\n      begin\n        self.listen do |t|\n          begin\n            res = block.call(t)\n            stream.send(res)\n          rescue ex\n            on_error.call(t, ex)\n          end\n        end\n      ensure\n        countdown.send(nil)\n      end\n    end\n  end\n  spawn(name: name.try do |s|\n    \"#{s}.countdown\"\n  end) do\n    workers.times do\n      countdown.receive\n    end\n    countdown.close\n    stream.close\n  end\nend"}},{"html_id":"merge(other:Channel(J),name=nil,buffer_size=0):Channel(T|J)forallJ-instance-method","name":"merge","doc":"Returns a channel that receives values from both *self* and *other*, as soon as they are available.\n\nThe returned channel is closed as soon as both the input channels are closed and empty - but will\ncontinue to operate while at least one of them is open.\n\nNOTE: If both channels have values ready to be received, then one will be selected at random. ","summary":"<p>Returns a channel that receives values from both <em>self</em> and <em>other</em>, as soon as they are available.</p>","abstract":false,"args":[{"name":"other","external_name":"other","restriction":"Channel(J)"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"args_string":"(other : Channel(J), name = nil, buffer_size = 0) : Channel(T | J) forall J","args_html":"(other : <a href=\"Channel.html\">Channel</a>(J), name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>) : <a href=\"Channel.html\">Channel</a>(T | J) forall J","location":{"filename":"src/concur/channel.cr","line_number":24,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L24"},"def":{"name":"merge","args":[{"name":"other","external_name":"other","restriction":"Channel(J)"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"return_type":"Channel(T | J)","visibility":"Public","body":"channels = [self, other]\n(Channel(T | J).new(buffer_size)).tap do |stream|\n  spawn(name: name) do\n    loop do\n      begin\n        stream.send(Channel.receive_first(channels.shuffle))\n      rescue Channel::ClosedError\n        channels.reject!(&.closed?)\n        if channels.empty?\n          break\n        end\n      end\n    end\n    stream.close\n  end\nend\n"}},{"html_id":"partition(name=nil,buffer_size=0,on_error=->(t:T,ex:Exception)do\nend,&predicate:T->Bool):Tuple(Channel(T),Channel(T))-instance-method","name":"partition","doc":"Returns a tuple of two channels, one receiving values that satisfy\nthe given *predicate* and one receiving the remaining ones.\n\nThe returned channels will close once `self` is closed and empty.\n\nSee `#select` for details on the exception handling strategy.","summary":"<p>Returns a tuple of two channels, one receiving values that satisfy the given <em>predicate</em> and one receiving the remaining ones.</p>","abstract":false,"args":[{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"args_string":"(name = nil, buffer_size = 0, on_error = ->(t : T, ex : Exception) do\nend, &predicate : T -> Bool) : Tuple(Channel(T), Channel(T))","args_html":"(name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, on_error = -&gt;(t : <span class=\"t\">T</span>, ex : <span class=\"t\">Exception</span>) <span class=\"k\">do</span>\n<span class=\"k\">end</span>, &predicate : T -> Bool) : Tuple(<a href=\"Channel.html\">Channel</a>(T), <a href=\"Channel.html\">Channel</a>(T))","location":{"filename":"src/concur/channel.cr","line_number":289,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L289"},"def":{"name":"partition","args":[{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"yields":1,"block_arg":{"name":"predicate","external_name":"predicate","restriction":"(T -> Bool)"},"return_type":"::Tuple(Channel(T), Channel(T))","visibility":"Public","body":"{Channel(T).new(buffer_size), Channel(T).new(buffer_size)}.tap do |pass, fail|\n  spawn(name: name) do\n    self.listen do |t|\n      begin\n        predicate.call(t) ? (        pass.send(t)) : (        fail.send(t))\n      rescue ex\n        on_error.call(t, ex)\n      end\n    end\n    pass.close\n    fail.close\n  end\nend"}},{"html_id":"rate_limit(items_per_sec:Float64,max_burst:Int32=1,name=nil,buffer_size=0)-instance-method","name":"rate_limit","doc":"Returns a channel that receives at most *items_per_sec* items per second from the\ncaller - or *max_burst* items, if no elements were received in a while.\n\nThe returned channel is closed once `self` is closed and empty and a new value\ncan be received, based on the rate limiting parameters.\n\nRefer to the documentation of [RateLimiter](https://github.com/lbarasti/rate_limiter)\nfor more details.","summary":"<p>Returns a channel that receives at most <em>items_per_sec</em> items per second from the caller - or <em>max_burst</em> items, if no elements were received in a while.</p>","abstract":false,"args":[{"name":"items_per_sec","external_name":"items_per_sec","restriction":"Float64"},{"name":"max_burst","default_value":"1","external_name":"max_burst","restriction":"Int32"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"args_string":"(items_per_sec : Float64, max_burst : Int32 = 1, name = nil, buffer_size = 0)","args_html":"(items_per_sec : Float64, max_burst : Int32 = <span class=\"n\">1</span>, name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>)","location":{"filename":"src/concur/channel.cr","line_number":47,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L47"},"def":{"name":"rate_limit","args":[{"name":"items_per_sec","external_name":"items_per_sec","restriction":"Float64"},{"name":"max_burst","default_value":"1","external_name":"max_burst","restriction":"Int32"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"visibility":"Public","body":"rl = RateLimiter.new(rate: items_per_sec, max_burst: max_burst)\n(Channel(T).new(buffer_size)).tap do |stream|\n  spawn(name: name) do\n    begin\n      loop do\n        rl.get\n        stream.send(self.receive)\n      end\n    rescue Channel::ClosedError\n      stream.close\n    end\n  end\nend\n"}},{"html_id":"reject(name=nil,buffer_size=0,on_error=->(t:T,ex:Exception)do\nend,&predicate:T->Bool):Channel(T)-instance-method","name":"reject","doc":"Returns a channel which receives values received by `self`\nthat do **not** satisfy the given *predicate*.\n\nThe returned channels will close once `self` is closed and empty.\n\nSee `#select` for details on the exception handling strategy.","summary":"<p>Returns a channel which receives values received by <code>self</code> that do <strong>not</strong> satisfy the given <em>predicate</em>.</p>","abstract":false,"args":[{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"args_string":"(name = nil, buffer_size = 0, on_error = ->(t : T, ex : Exception) do\nend, &predicate : T -> Bool) : Channel(T)","args_html":"(name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, on_error = -&gt;(t : <span class=\"t\">T</span>, ex : <span class=\"t\">Exception</span>) <span class=\"k\">do</span>\n<span class=\"k\">end</span>, &predicate : T -> Bool) : <a href=\"Channel.html\">Channel</a>(T)","location":{"filename":"src/concur/channel.cr","line_number":272,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L272"},"def":{"name":"reject","args":[{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"yields":1,"block_arg":{"name":"predicate","external_name":"predicate","restriction":"(T -> Bool)"},"return_type":"Channel(T)","visibility":"Public","body":"self.select(name: name, buffer_size: buffer_size, on_error: on_error) do |v|\n  !(predicate.call(v))\nend"}},{"html_id":"scan(acc:U,name=nil,buffer_size=0,on_error=->(t:T,ex:Exception)do\nend,&block:U,T->U):Channel(U)forallU-instance-method","name":"scan","doc":"Returns a channel that receives each successive accumulated state produced by *block*,\nbased on the initial state *acc* and on the values received by `self`.\n\nThe returned channel is closed once `self` is closed and empty, and any outstanding\nrun of *block* is completed.\n\nSee `#map` for details on the exception handling strategy.","summary":"<p>Returns a channel that receives each successive accumulated state produced by <em>block</em>, based on the initial state <em>acc</em> and on the values received by <code>self</code>.</p>","abstract":false,"args":[{"name":"acc","external_name":"acc","restriction":"U"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"args_string":"(acc : U, name = nil, buffer_size = 0, on_error = ->(t : T, ex : Exception) do\nend, &block : U, T -> U) : Channel(U) forall U","args_html":"(acc : U, name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, on_error = -&gt;(t : <span class=\"t\">T</span>, ex : <span class=\"t\">Exception</span>) <span class=\"k\">do</span>\n<span class=\"k\">end</span>, &block : U, T -> U) : <a href=\"Channel.html\">Channel</a>(U) forall U","location":{"filename":"src/concur/channel.cr","line_number":164,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L164"},"def":{"name":"scan","args":[{"name":"acc","external_name":"acc","restriction":"U"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"yields":2,"block_arg":{"name":"block","external_name":"block","restriction":"(U, T -> U)"},"return_type":"Channel(U)","visibility":"Public","body":"map(acc, name, buffer_size, on_error) do |state, v|\n  res = block.call(state, v)\n  {res, res}\nend"}},{"html_id":"select(name=nil,buffer_size=0,on_error=->(t:T,ex:Exception)do\nend,&predicate:T->Bool):Channel(T)-instance-method","name":"select","doc":"Returns a channel which receives values received by `self`\nthat satisfy the given *predicate*.\n\nThe returned channels will close once `self` is closed and empty.\n\nAny exception raised while evaluating *predicate* will be passed\nto the optional callback *on_error*, together with the value that\ntriggered the error.","summary":"<p>Returns a channel which receives values received by <code>self</code> that satisfy the given <em>predicate</em>.</p>","abstract":false,"args":[{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"args_string":"(name = nil, buffer_size = 0, on_error = ->(t : T, ex : Exception) do\nend, &predicate : T -> Bool) : Channel(T)","args_html":"(name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, on_error = -&gt;(t : <span class=\"t\">T</span>, ex : <span class=\"t\">Exception</span>) <span class=\"k\">do</span>\n<span class=\"k\">end</span>, &predicate : T -> Bool) : <a href=\"Channel.html\">Channel</a>(T)","location":{"filename":"src/concur/channel.cr","line_number":243,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L243"},"def":{"name":"select","args":[{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(t : T, ex : Exception) do\nend","external_name":"on_error","restriction":""}],"yields":1,"block_arg":{"name":"predicate","external_name":"predicate","restriction":"(T -> Bool)"},"return_type":"Channel(T)","visibility":"Public","body":"(Channel(T).new(buffer_size)).tap do |stream|\n  spawn(name: name) do\n    begin\n      loop do\n        t = self.receive\n        begin\n          should_send = predicate.call(t)\n          if should_send\n            stream.send(t)\n          end\n        rescue ex\n          on_error.call(t, ex)\n        end\n      end\n    rescue Channel::ClosedError\n      stream.close\n    end\n  end\nend"}},{"html_id":"take(max_items:Int32)-instance-method","name":"take","doc":"Returns an enumerable of values received from `self` containing at most *max_items* elements.\n\nIf `self` is closed in the process, then the returned enumerable might include fewer elements.","summary":"<p>Returns an enumerable of values received from <code>self</code> containing at most <em>max_items</em> elements.</p>","abstract":false,"args":[{"name":"max_items","external_name":"max_items","restriction":"Int32"}],"args_string":"(max_items : Int32)","args_html":"(max_items : Int32)","location":{"filename":"src/concur/channel.cr","line_number":8,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L8"},"def":{"name":"take","args":[{"name":"max_items","external_name":"max_items","restriction":"Int32"}],"visibility":"Public","body":"([] of T).tap do |items|\n  (1..max_items).each do\n    begin\n      items << self.receive\n    rescue Channel::ClosedError\n      break\n    end\n  end\nend"}},{"html_id":"zip(other:Channel(U),name=nil,buffer_size=0,on_error=->(tu:::Tuple(T,U),ex:Exception)do\nend,&block:T,U->V):Channel(V)forallU,V-instance-method","name":"zip","doc":"Returns a channel that receives tuples of values coming from `self` and *other*\ntransformed via *block*.\n\nThe returned channel is closed once either `self` or `other` are closed and empty,\nand any outstanding run of *block* is completed.\n\nSee `#map` for details on the exception handling strategy.","summary":"<p>Returns a channel that receives tuples of values coming from <code>self</code> and <em>other</em> transformed via <em>block</em>.</p>","abstract":false,"args":[{"name":"other","external_name":"other","restriction":"Channel(U)"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(tu : ::Tuple(T, U), ex : Exception) do\nend","external_name":"on_error","restriction":""}],"args_string":"(other : Channel(U), name = nil, buffer_size = 0, on_error = ->(tu : ::Tuple(T, U), ex : Exception) do\nend, &block : T, U -> V) : Channel(V) forall U, V","args_html":"(other : <a href=\"Channel.html\">Channel</a>(U), name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, on_error = -&gt;(tu : <span class=\"t\">::</span><span class=\"t\">Tuple</span>(<span class=\"t\">T</span>, <span class=\"t\">U</span>), ex : <span class=\"t\">Exception</span>) <span class=\"k\">do</span>\n<span class=\"k\">end</span>, &block : T, U -> V) : <a href=\"Channel.html\">Channel</a>(V) forall U, V","location":{"filename":"src/concur/channel.cr","line_number":184,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/channel.cr#L184"},"def":{"name":"zip","args":[{"name":"other","external_name":"other","restriction":"Channel(U)"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"on_error","default_value":"->(tu : ::Tuple(T, U), ex : Exception) do\nend","external_name":"on_error","restriction":""}],"yields":2,"block_arg":{"name":"block","external_name":"block","restriction":"(T, U -> V)"},"return_type":"Channel(V)","visibility":"Public","body":"(Channel(V).new(buffer_size)).tap do |stream|\n  spawn(name: name) do\n    begin\n      loop do\n        p1 = self.receive\n        p2 = other.receive\n        begin\n          res = block.call(p1, p2)\n          stream.send(res)\n        rescue ex\n          on_error.call({p1, p2}, ex)\n        end\n      end\n    rescue Channel::ClosedError\n      stream.close\n    end\n  end\nend"}}]},{"html_id":"concur/Concur","path":"Concur.html","kind":"module","full_name":"Concur","name":"Concur","abstract":false,"locations":[{"filename":"src/concur/concur.cr","line_number":3,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/concur.cr#L3"}],"repository_name":"concur","program":false,"enum":false,"alias":false,"const":false,"extended_modules":[{"html_id":"concur/Concur","kind":"module","full_name":"Concur","name":"Concur"}],"instance_methods":[{"html_id":"every(t:Time::Span,name=nil,buffer_size=0,terminate=Channel(Time).new,&block:->T):Channel(T)forallT-instance-method","name":"every","doc":"Returns a channel that will receive the value returned by *block* at\nintervals of at least *t* between one call and the other.\n\nIf an exception is raised while running a block, then the returned channel will be closed.\n\nAn optional channel `terminate` can be passed to the method. Sending an object to this\nchannel - or closing it - will halt the sending of new values as soon as any outstanding run of *block*\nis completed and close the returned channel.\n\nNOTE: Only a single instance of *block* can be running at any given time. If the\nblock takes a time `x` to complete, then the time between two runs of *block* will be\nat least `t + x`.","summary":"<p>Returns a channel that will receive the value returned by <em>block</em> at intervals of at least <em>t</em> between one call and the other.</p>","abstract":false,"args":[{"name":"t","external_name":"t","restriction":"Time::Span"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"terminate","default_value":"Channel(Time).new","external_name":"terminate","restriction":""}],"args_string":"(t : Time::Span, name = nil, buffer_size = 0, terminate = Channel(Time).new, &block :  -> T) : Channel(T) forall T","args_html":"(t : Time::Span, name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, terminate = <span class=\"t\">Channel</span>(<span class=\"t\">Time</span>).<span class=\"k\">new</span>, &block :  -> T) : <a href=\"Channel.html\">Channel</a>(T) forall T","location":{"filename":"src/concur/concur.cr","line_number":53,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/concur.cr#L53"},"def":{"name":"every","args":[{"name":"t","external_name":"t","restriction":"Time::Span"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""},{"name":"terminate","default_value":"Channel(Time).new","external_name":"terminate","restriction":""}],"yields":0,"block_arg":{"name":"block","external_name":"block","restriction":"(-> T)"},"return_type":"Channel(T)","visibility":"Public","body":"(Channel(T).new(buffer_size)).tap do |stream|\n  spawn(name: name) do\n    begin\n      loop do\n        select\nwhen timeout(t)\n          stream.send(block.call)\nwhen time = terminate.receive?\n          break\nend\n\n      end\n    ensure\n      stream.close\n    end\n  end\nend"}},{"html_id":"flatten(in_stream:Channel(Enumerable(K)),name=nil,buffer_size=0):Channel(K)forallK-instance-method","name":"flatten","doc":"Returns a channel that will receive each element of the enumerables received by\n*in_stream*, one at a time.\n\nIf *in_stream* is closed, then the returned stream will also be closed once *in_stream* has been emptied.","summary":"<p>Returns a channel that will receive each element of the enumerables received by <em>in_stream</em>, one at a time.</p>","abstract":false,"args":[{"name":"in_stream","external_name":"in_stream","restriction":"Channel(Enumerable(K))"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"args_string":"(in_stream : Channel(Enumerable(K)), name = nil, buffer_size = 0) : Channel(K) forall K","args_html":"(in_stream : <a href=\"Channel.html\">Channel</a>(Enumerable(K)), name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>) : <a href=\"Channel.html\">Channel</a>(K) forall K","location":{"filename":"src/concur/concur.cr","line_number":74,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/concur.cr#L74"},"def":{"name":"flatten","args":[{"name":"in_stream","external_name":"in_stream","restriction":"Channel(Enumerable(K))"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"return_type":"Channel(K)","visibility":"Public","body":"(Channel(K).new(buffer_size)).tap do |stream|\n  spawn(name: name) do\n    begin\n      loop do\n        in_stream.receive.each do |v|\n          stream.send(v)\n        end\n      end\n    rescue Channel::ClosedError\n      stream.close\n    end\n  end\nend"}},{"html_id":"source(input:Enumerable(T),name=nil,buffer_size=0):Channel(T)forallT-instance-method","name":"source","doc":"Returns a channel that will receive each element in the given enumerable,\nand then close.","summary":"<p>Returns a channel that will receive each element in the given enumerable, and then close.</p>","abstract":false,"args":[{"name":"input","external_name":"input","restriction":"Enumerable(T)"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"args_string":"(input : Enumerable(T), name = nil, buffer_size = 0) : Channel(T) forall T","args_html":"(input : Enumerable(T), name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>) : <a href=\"Channel.html\">Channel</a>(T) forall T","location":{"filename":"src/concur/concur.cr","line_number":8,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/concur.cr#L8"},"def":{"name":"source","args":[{"name":"input","external_name":"input","restriction":"Enumerable(T)"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"return_type":"Channel(T)","visibility":"Public","body":"(Channel(T).new(buffer_size)).tap do |stream|\n  spawn(name: name) do\n    begin\n      input.each do |value|\n        stream.send(value)\n      end\n    ensure\n      stream.close\n    end\n  end\nend"}},{"html_id":"source(initial_state:S,name=nil,buffer_size=0,&block:S->Tuple(S,V))forallS,V-instance-method","name":"source","doc":"Returns a channel that will receive each value generated by recursively calling\n*block*, starting from the given *initial_state*.\n\nIf an exception is raised while running a block, then the returned channel will be closed.\n\nNOTE: *block* is a function returning a tuple composed of the next state\nto be passed to the block and the next value to be received by the returned channel.","summary":"<p>Returns a channel that will receive each value generated by recursively calling <em>block</em>, starting from the given <em>initial_state</em>.</p>","abstract":false,"args":[{"name":"initial_state","external_name":"initial_state","restriction":"S"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"args_string":"(initial_state : S, name = nil, buffer_size = 0, &block : S -> Tuple(S, V)) forall S, V","args_html":"(initial_state : S, name = <span class=\"n\">nil</span>, buffer_size = <span class=\"n\">0</span>, &block : S -> Tuple(S, V)) forall S, V","location":{"filename":"src/concur/concur.cr","line_number":27,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/concur.cr#L27"},"def":{"name":"source","args":[{"name":"initial_state","external_name":"initial_state","restriction":"S"},{"name":"name","default_value":"nil","external_name":"name","restriction":""},{"name":"buffer_size","default_value":"0","external_name":"buffer_size","restriction":""}],"yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(S -> ::Tuple(S, V))"},"visibility":"Public","body":"(Channel(V).new(buffer_size)).tap do |stream|\n  spawn(name: name) do\n    begin\n      state = initial_state\n      loop do\n        state, value = block.call(state)\n        stream.send(value)\n      end\n    ensure\n      stream.close\n    end\n  end\nend"}}]},{"html_id":"concur/Future","path":"Future.html","kind":"class","full_name":"Future(T)","name":"Future","abstract":false,"superclass":{"html_id":"concur/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"concur/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"concur/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/concur/future.cr","line_number":3,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L3"}],"repository_name":"concur","program":false,"enum":false,"alias":false,"const":false,"doc":"A Future represents a value which may or may not *currently* be available, but will be\navailable at some point, or an exception if that value could not be made available.","summary":"<p>A Future represents a value which may or may not <em>currently</em> be available, but will be available at some point, or an exception if that value could not be made available.</p>","constructors":[{"html_id":"new(&block:->T)-class-method","name":"new","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":13,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L13"},"def":{"name":"new","yields":0,"block_arg":{"name":"block","external_name":"block","restriction":"(-> T)"},"visibility":"Public","body":"_ = Future(T).allocate\n_.initialize(&block) do\n  yield\nend\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"html_id":"await(t:Time::Span):T|Exception-instance-method","name":"await","doc":"Same as `#await`, but returns a `Timeout` exception if the given `t` expires.","summary":"<p>Same as <code><a href=\"Future.html#await%3AT%7CException-instance-method\">#await</a></code>, but returns a <code><a href=\"Future/Timeout.html\">Timeout</a></code> exception if the given <code>t</code> expires.</p>","abstract":false,"args":[{"name":"t","external_name":"t","restriction":"Time::Span"}],"args_string":"(t : Time::Span) : T | Exception","args_html":"(t : Time::Span) : T | Exception","location":{"filename":"src/concur/future.cr","line_number":52,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L52"},"def":{"name":"await","args":[{"name":"t","external_name":"t","restriction":"Time::Span"}],"return_type":"T | Exception","visibility":"Public","body":"if done?\nelse\n  select\nwhen timeout(t)\n    return Timeout.new\nwhen res = @value_ch.receive?\n    if res\n      @value = res\n    end\nwhen err = @error_ch.receive?\n    if err\n      @error = err\n    end\nend\n\n  @value_ch.close\n  @error_ch.close\nend\n@error ? @error.not_nil! : @value.not_nil!\n"}},{"html_id":"await:T|Exception-instance-method","name":"await","doc":"Awaits the completion of the future and returns either a value or an exception.","summary":"<p>Awaits the completion of the future and returns either a value or an exception.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":26,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L26"},"def":{"name":"await","return_type":"T | Exception","visibility":"Public","body":"if done?\nelse\n  select\nwhen res = @value_ch.receive?\n    if res\n      @value = res\n    end\nwhen err = @error_ch.receive?\n    if err\n      @error = err\n    end\nend\n\n  @value_ch.close\n  @error_ch.close\nend\n@error ? @error.not_nil! : @value.not_nil!\n"}},{"html_id":"await!(t:Time::Span):T-instance-method","name":"await!","doc":"Same as `#await!`, but raises a `Timeout` exception if the given `t` expires.","summary":"<p>Same as <code><a href=\"Future.html#await%21%3AT-instance-method\">#await!</a></code>, but raises a <code><a href=\"Future/Timeout.html\">Timeout</a></code> exception if the given <code>t</code> expires.</p>","abstract":false,"args":[{"name":"t","external_name":"t","restriction":"Time::Span"}],"args_string":"(t : Time::Span) : T","args_html":"(t : Time::Span) : T","location":{"filename":"src/concur/future.cr","line_number":69,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L69"},"def":{"name":"await!","args":[{"name":"t","external_name":"t","restriction":"Time::Span"}],"return_type":"T","visibility":"Public","body":"case res = await(t)\nwhen T\n  res\nelse\n  raise(res)\nend"}},{"html_id":"await!:T-instance-method","name":"await!","doc":"Awaits the completion of the future and either returns the computed value\nor raises an exception.","summary":"<p>Awaits the completion of the future and either returns the computed value or raises an exception.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":42,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L42"},"def":{"name":"await!","return_type":"T","visibility":"Public","body":"case res = await\nwhen T\n  res\nelse\n  raise(res)\nend"}},{"html_id":"done?-instance-method","name":"done?","doc":"Returns `true` if the future has completed - either with a value or an exception.\nReturns `false` otherwise.","summary":"<p>Returns <code>true</code> if the future has completed - either with a value or an exception.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":80,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L80"},"def":{"name":"done?","visibility":"Public","body":"@value_ch.closed?"}},{"html_id":"flat_map(&block:T->Future(K)):Future(K)forallK-instance-method","name":"flat_map","doc":"Creates a new future by applying a function to the successful result of this future,\nand returns the result of the function as the new future.\n\nIf this future is completed with an exception then the new future will also contain this exception.","summary":"<p>Creates a new future by applying a function to the successful result of this future, and returns the result of the function as the new future.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":88,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L88"},"def":{"name":"flat_map","yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T -> Future(K))"},"return_type":"Future(K)","visibility":"Public","body":"map do |value|\n  (block.call(value)).await!\nend"}},{"html_id":"flatten-instance-method","name":"flatten","doc":"Creates a new future with one level of nesting flattened.","summary":"<p>Creates a new future with one level of nesting flattened.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":95,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L95"},"def":{"name":"flatten","visibility":"Public","body":"flat_map do |fut|\n  fut\nend"}},{"html_id":"map(&block:T->K):Future(K)forallK-instance-method","name":"map","doc":"Creates a new future by applying a function to the successful result of this future.\n\nIf this future is completed with an exception then the new future will also contain this exception.","summary":"<p>Creates a new future by applying a function to the successful result of this future.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":102,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L102"},"def":{"name":"map","yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T -> K)"},"return_type":"Future(K)","visibility":"Public","body":"transform do |res|\n  case res\n  when T\n    block.call(res)\n  else\n    raise(res)\n  end\nend"}},{"html_id":"map_to(typ:Object.class)-instance-method","name":"map_to","doc":"Creates a new Future which is completed with this Future's result if\nthat conforms to type `typ` or a `TypeCastError` otherwise.","summary":"<p>Creates a new Future which is completed with this Future's result if that conforms to type <code>typ</code> or a <code>TypeCastError</code> otherwise.</p>","abstract":false,"args":[{"name":"typ","external_name":"typ","restriction":"Object.class"}],"args_string":"(typ : Object.class)","args_html":"(typ : <span class=\"t\">Object</span>.<span class=\"k\">class</span>)","location":{"filename":"src/concur/future.cr","line_number":115,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L115"},"def":{"name":"map_to","args":[{"name":"typ","external_name":"typ","restriction":"Object.class"}],"visibility":"Public","body":"map do |value|\n  typ.cast(value)\nend"}},{"html_id":"on_complete(&block:T|Exception->_):Future(T)-instance-method","name":"on_complete","doc":"Applies the side-effecting function to the result of this future, and returns a new future\nwith the result of this future.\n\nThis method allows one to enforce that the callbacks are executed in a specified order.\nNote: if one of the chained `on_complete` callbacks throws an exception, that exception is not\npropagated to the subsequent `on_complete` callbacks. Instead, the subsequent `on_complete` callbacks\nare given the original value of this future.","summary":"<p>Applies the side-effecting function to the result of this future, and returns a new future with the result of this future.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":126,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L126"},"def":{"name":"on_complete","yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T | Exception -> _)"},"return_type":"Future(T)","visibility":"Public","body":"transform do |res|\n  begin\n    block.call(res)\n  rescue\n  end\n  case res\n  when T\n    res\n  else\n    raise(res)\n  end\nend"}},{"html_id":"on_error(&block:Exception->_):Future(T)-instance-method","name":"on_error","doc":"Applies the side-effecting function to the result of this future if it raised an error, and\nreturns a new future with the result of this future.\n\nWARNING: Will not be called if this future is never completed or if it is completed with success.","summary":"<p>Applies the side-effecting function to the result of this future if it raised an error, and returns a new future with the result of this future.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":157,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L157"},"def":{"name":"on_error","yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(Exception -> _)"},"return_type":"Future(T)","visibility":"Public","body":"on_complete do |res|\n  case res\n  when Exception\n    block.call(res)\n  end\nend"}},{"html_id":"on_success(&block:T->_):Future(T)-instance-method","name":"on_success","doc":"Applies the side-effecting function to the result of this future if it was successful, and\nreturns a new future with the result of this future.\n\nWARNING: Will not be called if this future is never completed or if it is completed with an error.","summary":"<p>Applies the side-effecting function to the result of this future if it was successful, and returns a new future with the result of this future.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":144,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L144"},"def":{"name":"on_success","yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T -> _)"},"return_type":"Future(T)","visibility":"Public","body":"on_complete do |res|\n  case res\n  when T\n    block.call(res)\n  end\nend"}},{"html_id":"recover(&block:Exception->T):Future(T)-instance-method","name":"recover","doc":"Creates a new future that will handle any matching throwable that this future might contain.\nIf there is no match, or if this future contains a valid result then the new future will contain the same.","summary":"<p>Creates a new future that will handle any matching throwable that this future might contain.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":168,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L168"},"def":{"name":"recover","yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(Exception -> T)"},"return_type":"Future(T)","visibility":"Public","body":"transform do |res|\n  case res\n  when T\n    res\n  else\n    block.call(res)\n  end\nend"}},{"html_id":"select(&block:T->Bool):Future(T)-instance-method","name":"select","doc":"Creates a new future by filtering the value of the current future with a predicate.\n\nIf the current future contains a value which satisfies the predicate, the new future will also hold that value.\nOtherwise, the resulting future will fail with a `EmptyError`.\nIf the current future fails, then the resulting future also fails.","summary":"<p>Creates a new future by filtering the value of the current future with a predicate.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":184,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L184"},"def":{"name":"select","yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T -> Bool)"},"return_type":"Future(T)","visibility":"Public","body":"map do |value|\n  if block.call(value)\n    value\n  else\n    raise(EmptyError.new)\n  end\nend"}},{"html_id":"transform(&block:T|Exception->K):Future(K)forallK-instance-method","name":"transform","doc":"Creates a new Future by applying the specified function to the result of this Future.\n\nIf there is any non-fatal exception thrown when 'block' is applied then that exception\nwill be propagated to the resulting future.","summary":"<p>Creates a new Future by applying the specified function to the result of this Future.</p>","abstract":false,"location":{"filename":"src/concur/future.cr","line_number":198,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L198"},"def":{"name":"transform","yields":1,"block_arg":{"name":"block","external_name":"block","restriction":"(T | Exception -> K)"},"return_type":"Future(K)","visibility":"Public","body":"Future.new do\n  block.call(self.await)\nend"}},{"html_id":"zip(other:Future(K),&block:T,K->W):Future(W)forallK,W-instance-method","name":"zip","doc":"Creates a new future holding the result of `block` applied to the tuple of values from two futures.","summary":"<p>Creates a new future holding the result of <code>block</code> applied to the tuple of values from two futures.</p>","abstract":false,"args":[{"name":"other","external_name":"other","restriction":"Future(K)"}],"args_string":"(other : Future(K), &block : T, K -> W) : Future(W) forall K, W","args_html":"(other : <a href=\"Future.html\">Future</a>(K), &block : T, K -> W) : <a href=\"Future.html\">Future</a>(W) forall K, W","location":{"filename":"src/concur/future.cr","line_number":205,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L205"},"def":{"name":"zip","args":[{"name":"other","external_name":"other","restriction":"Future(K)"}],"yields":2,"block_arg":{"name":"block","external_name":"block","restriction":"(T, K -> W)"},"return_type":"Future(W)","visibility":"Public","body":"flat_map do |t|\n  other.map do |k|\n    block.call(t, k)\n  end\nend"}}],"types":[{"html_id":"concur/Future/EmptyError","path":"Future/EmptyError.html","kind":"class","full_name":"Future::EmptyError","name":"EmptyError","abstract":false,"superclass":{"html_id":"concur/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"concur/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"concur/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"concur/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/concur/future.cr","line_number":4,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L4"}],"repository_name":"concur","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"concur/Future","kind":"class","full_name":"Future(T)","name":"Future"}},{"html_id":"concur/Future/Timeout","path":"Future/Timeout.html","kind":"class","full_name":"Future::Timeout","name":"Timeout","abstract":false,"superclass":{"html_id":"concur/Exception","kind":"class","full_name":"Exception","name":"Exception"},"ancestors":[{"html_id":"concur/Exception","kind":"class","full_name":"Exception","name":"Exception"},{"html_id":"concur/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"concur/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/concur/future.cr","line_number":7,"url":"https://github.com/lbarasti/concur/blob/fee0b7f51b2a778550f9bca5e9ed65ed0353cb6f/src/concur/future.cr#L7"}],"repository_name":"concur","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"concur/Future","kind":"class","full_name":"Future(T)","name":"Future"}}]}]}}